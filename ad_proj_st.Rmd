---
title: 'PROJECTE ANÀLISI DE DADES: Entrada Turística Espanya'
author: "David Anglada Rotger i Andreu Huguet Segarra"
date: "17/5/2019"
output:
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    df_print: paged
    number_sections: yes
    toc: yes
fig_width: 5
fig_height: 3
---

# Introducció

# Identificació

## Representació gràfica de les dades

Un cop feta la representació de les dades, s'observa una clara tendència creixent. Tot i així, aquesta tendència no és constant, ja que és menys pronunciada entre els anys 2000 i 2010, fins i tot amb una petita baixada entre els anys 2007i 2010 i sembla que es pronuncia a partir de l'any 2011. 

Pel que fa a la variància, s'observa que va augmentant a mesura que augmenta la mitjana dels valors de les dades, és a dir, a mesura que es pronuncia la tendència creixent. És a dir, en els anys 2000-2010, la variància és menor que en els anys 2011-2019, on el creixement augmenta.

```{r echo = FALSE}
serie<-ts(read.table("./data/EntradTur.dat")/1000000,start=2000,freq=12)
plot(serie,main="Entrada Turística a Espanya",ylab="Milions")
abline(v=1999:2019,col=4,lty=3)
```

### Descomposició en components bàsiques

Per poder analitzar millor les dades, es realitza la seva descomposició en les seves components bàsiques, és a dir, el model aditiu de la serie:

$$ X_t = T_t + S_t + C_t + \omega_t $$
on:
- $T_t$ és la **tendència** de la sèrie a llarg termini.
- $S_t$ és el __*seasonal*__ de la sèrie (patró repetit periòdicament amb període constant).
- $C_t$ és el **cicle** de la sèrie (patró repetit periòdicament amb període no constant). Aquesta part no surt representada en la descomposició.
- $\omega_t$ és el soroll aleatòri.

```{r echo = FALSE}
plot(decompose(serie))
```

S'observa, tal i com s'havia comentat anteriorment, la clara tendència creixent de la sèrie, amb un creixement menys pronunciat a l'inici, una petita baixada entre els anys 20017 i 2010 i una pujada més pronunciada més cap a l'actualitat. Pel que fa al patró estacional, observem que durant els mesos d'estiu, el número de turistes a Espanya augmenta molt considerablement. Aquest fet que no crida l'atenció, ja que és durant els mesos d'estiu quan més vacanses s'agafa la gent i més aprofiten per venir a les costes espanyoles. Durant els mesos de tardor-hivern, observem que el número de turistes cau en picat.

## Transformació de les dades

A continuació s'analitzarà la necessitat de realitzar una sèrie de transformacions amb l'objectiu d'aconseguir estacionaritat en la nostra sèrie temporal.

### Variància constant

En primer lloc, s'estudiarà si es pot considerar que la variància de les dades sigui constant en el temps. Ja s'ha comentat que a simple vista semblava que no. Tot i així es comprova amb un plot de la variància front la mitjana i un *boxplot* de les dades cada 12 mesos (que és la freqüència de les nostres dades).

```{r echo = FALSE}
par(mfrow=c(1,2))
m=apply(matrix(serie,nr=12),2,mean)
v=apply(matrix(serie,nr=12),2,var)
plot(m,v,xlab="Mitjanes anuals",ylab="Variàncies anuals",main="Mean-Variance Plot")
abline(lm(v~m),col=2,lty=3,lwd=2)

boxplot(serie~floor(time(serie)))
```

Tal i com s'havia observat a simple vista, la variància augmenta a mesura que agumenta la mitja. Per tant, no podem assumir variància constant. Amb el *boxplot* es confirma aquesta hipòtesis. Així doncs, es procedeix a realitzar una transformació logarítmica de la sèrie per homogeneïtzar la variància. Els resultats obtinguts són els següents:

```{r echo = FALSE}
logserie <- log(serie)

par(mfrow=c(1,2))
logm=apply(matrix(logserie,nr=12),2,mean)
logv=apply(matrix(logserie,nr=12),2,var)
plot(logm,logv,xlab="Mitjanes anuals",ylab="Variàncies anuals",main="Mean-Variance Plot")
abline(lm(logv~logm),col=2,lty=3,lwd=2)

boxplot(logserie~floor(time(logserie)))
```

S'observa que la variància s'ha homogeneïtzat, és a dir, ja es pot considerar constant.

### Patró estacional

En segon lloc, s'estudiarà l'existència d'un patró estacional en les nostres dades. En cas que hi sigui present, es realitzarà una diferenciació d'ordre 12, és a dir,

$$ W_t = X_t - X_{t-12} = (1 - B^{12})X_t $$
on $B$ és el *backshift operator*, per eliminar aquest patró. Es realitza un *monthplot* per comprovar-ne l'existència.

```{r echo = FALSE}
monthplot(logserie)
```

Tal i com s'havia comenta, s'observa una clara pujada de la presència de turistes durant els mesos d'estiu i una baixada en picat en l'entrada de l'hivern/tardor. Així doncs, és necessària una diferenciació d'ordre 12 per eliminar aquest patró.

```{r echo = FALSE}
d12logserie <- diff(logserie,12)
monthplot(d12logserie)
```

S'observa que amb una diferenciació d'ordre 12 s'ha eliminat el patró estacional. Ara bé, la mitjana de la sèrie encara no és constant.

### Mitjana constant

Per últim, es vol aconseguir que la sèrie tingui mitjana constant igual (i si és possible igual a 0) per a poder considerar definitivament la sèrie com un procés estacionari. Per aconseguir-ho, es realitzaran diferenciacions regulars de la sèrie fins que s'obtingui el resultat desitjat

$$ W_t = X_t - X_{t-1} = (1 - B)X_t $$

Es realitza la primera diferenciació. Els valors de mitjana i variància aconseguits són els seguents:

```{r echo = FALSE}
d1d12logserie <- diff(d12logserie)
plot(d1d12logserie)
mean(d1d12logserie)
var(d1d12logserie)
```

Com es pot observar, la mitjana del procés diferenciat regularment un cop es pot considerar constant i nula. Ara bé, es mira de diferenciar un segon cop i s'observa que la variància augmenta i, per tant, es té *overdifferentiation*. 

```{r echo = FALSE}
d1d1d12logserie <- diff(d1d12logserie)
plot(d1d1d12logserie)
mean(d1d1d12logserie)
var(d1d1d12logserie)
```

En definitiva, la sèrie transformada pel logaritme, diferenciada un cop i amb una diferenciació d'ordre 12 per eliminar el patró estacional ($\texttt{d1d12logserie}$) és un procés estacionari de mitjana 0.

## ACF/PACF de les dades i proposta de models

Tot seguit, es realitza un anàlisi de les funcions *AutoCorrelació* i de *Correlació Parcial* de la sèrie transformada, és a dir, de la sèrie estacionària.

```{r echo = FALSE}
par(mfrow=c(1,2))
acf(d1d12logserie,ylim=c(-1,1),col=c(2,rep(1,11)),lwd=2,lag.max=72)
pacf(d1d12logserie,ylim=c(-1,1),col=c(rep(1,11),2),lwd=2,lag.max=72)
par(mfrow=c(1,1))
```

### Models proposats per la part regular (p,d,q)

En relació a la part regular de la sèrie, en la funció d'AutoCorrelació (ACF) s'observa que només sobresurt el primer valor. La resta de valors es poden considerar nuls, ja que o bé estan dintre de l'interval de confiança, o bé es poden assignar al cas d'aleatorietat del 5%. Per tant, per la part regular, es proposaria $q=1$.

Pel que fa a la funció de Correlació Parcial (PACF) s'observa un decreixement exponencial dels primers valors. S'observen també valors fora de la banda de confiança, però poden ser assignats a la aleatorietat del cas 5%. Per tant, en aquest cas, es proposaria $p=0$. En tot cas, si es volgués mirar d'incloure el primer valor que sobresurt més que la resta, es podria considerar també $p=1$.

Donat que s'ha realitzat diferenciació 1 cop, es té que $d=1$. Per tant, els models proposats per la part regular serien $MA(1)$ o, en tot cas, $ARMA(1,1)$ sobre la sèrie transformada regular.

## Models proposats per la part estacional (P,D,Q)

En relació a la part estacional de la sèrie, en la funció d'AutoCorrelació (ACF) s'observa que el primer valor es força significatiu, però també ho són el tercer, el quart i el cinquè, sobretot el quart. Donat que volem intentar proposar un model simplificat, es proposa $Q=0$.

Pel que fa a la funció de Correlació Parcial (PACF) s'observa que sobresurt el primer valor una mica i també sobresurten el tercer i el quart valor. Ara bé, no sobresurten de manera tant significativa com en el cas dels valors del ACF i, per tant, podem assignar-ho al cas d'aleatorietat del 5%. Per tant, en aquest cas, es proposaria $P=1$.

Donat que s'ha realitzat una diferenciació d'ordre 12 per eliminar el patró estacional, es té que $D=1$. Per tant, el model proposat per la part regular seria un $AR(1)$

## Models proposats

En conclusió, es proposen per la sèrie diferenciada els models estacionals:

-$ARMA(0,1)(1,0)_s$
-$ARMA(1,1)(1,0)_s$

I per la sèrie original, tenint en compte les diferenciacions, es proposen:

-$SARIMA(0,1,1)(1,1,0)_s$
-$SARIMA(1,1,1)(1,1,0)_s$

```{r, echo = FALSE}
pdq.1 <- c(0, 1, 1)
PDQ.1 <- c(1, 1, 0)
(mod.1 <- arima(logserie, order=pdq.1, seasonal = list(order = PDQ.1, period=12)))
pdq.2 <- c(1, 1, 1)
PDQ.2 <- c(1, 1, 0)
(mod.2 <- arima(logserie, order = pdq.2, seasonal = list(order = PDQ.2, period=12)))
```

# Estimació dels models

# Validació dels Models

```{r}
source("validation.r")
```

```{r}
validation(mod.1, d1d12logserie)
```

```{r}
validation(mod.2, d1d12logserie)
```

## Estabilitat dels Models

```{r}
########### Estabilitat Model (SENSE CONSTANT!!!!) ###############
ultim=c(2017,12)

serie1=window(serie,end=ultim+c(1,0))
lnserie1=log(serie1)
serie2=window(serie,end=ultim)
lnserie2=log(serie2)

(mod1 <- arima(lnserie1, order=pdq.1, seasonal=list(order=PDQ.1, period=12)))
(mod2 <- arima(lnserie2, order=pdq.1, seasonal=list(order=PDQ.1, period=12)))
```

# Previsions a llarg termini

```{r}
pred=predict(mod2,n.ahead=12)
pr<-ts(c(tail(lnserie2,1),pred$pred),start=ultim,freq=12)

se<-ts(c(0,pred$se),start=ultim,freq=12)

#Intervals
tl<-ts(exp(pr-1.96*se),start=ultim,freq=12)
tu<-ts(exp(pr+1.96*se),start=ultim,freq=12)
pr<-ts(exp(pr),start=ultim,freq=12)


ts.plot(serie,tl,tu,pr,
        lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-3,+2),
        type="o",main="Model ARIMA(0,1,1)(1,1,0)12")
abline(v=(ultim[1]-3):(ultim[1]+2),lty=3,col=4)
```

```{r}
(previs=window(cbind(tl,pr,tu,serie,error=round(serie-pr,3)),start=ultim))

obs=window(serie,start=ultim)
(mod.EQM1=sqrt(sum(((obs-pr)/obs)^2)/12))
(mod.EAM1=sum(abs(obs-pr)/obs)/12)
```

```{r}
##### Previsions a llarg termini amb el model complet ######
mod <- mod.1
lnserie <- logserie
pred=predict(mod,n.ahead=12)
pr<-ts(c(tail(lnserie,1),pred$pred),start=ultim+c(1,0),freq=12)
se<-ts(c(0,pred$se),start=ultim+c(1,0),freq=12)

#Intervals
tl1<-ts(exp(pr-1.96*se),start=ultim+c(1,0),freq=12)
tu1<-ts(exp(pr+1.96*se),start=ultim+c(1,0),freq=12)
pr1<-ts(exp(pr),start=ultim+c(1,0),freq=12)

ts.plot(serie,tl1,tu1,pr1,
        lty=c(1,2,2,1), col=c(1,4,4,2), xlim=c(ultim[1]-2,ultim[1]+3),
        type="o",main="Model ARIMA(0,1,1)(1,1,0)12")
abline(v=(ultim[1]-2):(ultim[1]+3),lty=3,col=4)
```

```{r}
(previs1=window(cbind(tl1,pr1,tu1),start=ultim+c(1,0)))
```

# Tractament de *outliers*

```{r}
########## At?pics ###############################################
source("./airbcn/atipics2.R")

##Detecci?n de at?picos: hay una diferenciaci?n regular y una de orden 12, fijamos el criterio a 2.8 y buscamos tambi?n LS
mod.atip=outdetec(mod,dif=c(1,12),crit=2.8,LS=T)

##Tabla de at?picos encontrados con su fecha
atipics=mod.atip$atip[order(mod.atip$atip[,1]),]
meses=c("Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic")
data.frame(atipics,Fecha=paste(meses[(atipics[,1]-1)%%12+1],start(lnserie)[1]+((atipics[,1]-1)%/%12)))
mod.atip$sigma2

data.frame(atipics,Fecha=paste(meses[(atipics[,1]-1)%%12+1],start(lnserie)[1]+((atipics[,1]-1)%/%12)),perc.Obs=exp(atipics[,3])*100)
```


```{r}

##Comparaci?n serie observada con la serie linealizada (sin at?picos)
lnserie.lin=lineal(lnserie,mod.atip$atip)
serie.lin=exp(lnserie.lin)

plot(serie.lin,col=2)
lines(serie)
```

```{r}
##Efecto de los at?picos en la serie de logaritmos
plot(lnserie-lnserie.lin)
```

```{r}
##Identificaci?n del modelo para la serie linealizada
d1d12lnserie.lin=diff(diff(lnserie.lin,12))
par(mfrow=c(1,2))
acf(d1d12lnserie.lin,ylim=c(-1,1),lag.max=72,col=c(2,rep(1,11)),lwd=2)
pacf(d1d12lnserie.lin,ylim=c(-1,1),lag.max=72,col=c(rep(1,11),2),lwd=2)
par(mfrow=c(1,1))
```

```{r}
##Estimaci?n del modelo para la serie linealizada
(mod.lin=arima(lnserie.lin,order=pdq.1,seasonal=list(order=PDQ.1,period=12)))
```


```{r}
dades=d1d12lnserie.lin
model=mod.lin
validation(model,dades)
```

```{r}
########### Estabilitat Modelpara la serie linealizada (SENSE CONSTANT!!!!) ###############
ultim=c(2017,12)

serie1.lin=window(serie.lin,end=ultim+c(1,0))
lnserie1.lin=log(serie1.lin)
serie2.lin=window(serie.lin,end=ultim)
lnserie2.lin=log(serie2.lin)

(mod.lin=arima(lnserie1.lin,order=c(0,1,1),seasonal=list(order=c(2,1,0),period=12)))
(mod2.lin=arima(lnserie2.lin,order=c(0,1,1),seasonal=list(order=c(2,1,0),period=12)))
```


```{r}
pred=predict(mod2.lin,n.ahead=12)
wLS=sum(mod.atip$atip[mod.atip$atip$type_detected=="LS" & mod.atip$atip$Obs<=length(serie)-12,3])
predic=pred$pr+wLS
pr<-ts(c(tail(lnserie2,1),predic),start=ultim,freq=12)
se<-ts(c(0,pred$se),start=ultim,freq=12)

#Intervals
tl<-ts(exp(pr-1.96*se),start=ultim,freq=12)
tu<-ts(exp(pr+1.96*se),start=ultim,freq=12)
pr<-ts(exp(pr),start=ultim,freq=12)

ts.plot(serie,tl,tu,pr,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-3,+2),type="o",main="Model ARIMA(0,1,1)(1,1,0)12")
abline(v=(ultim[1]-3):(ultim[1]+2),lty=3,col=4)
```

```{r}
(previs.lin=window(cbind(tl,pr,tu,serie,error=round(serie-pr,3)),start=ultim))
```

```{r}
obs=window(serie,start=ultim)
(mod.EQM2=sqrt(sum(((obs-pr)/obs)^2)/12))
(mod.EAM2=sum(abs(obs-pr)/obs)/12)
```


```{r}
##### Previsions a llarg termini amb el model complet ######

pred=predict(mod.lin,n.ahead=12)
wLS=sum(mod.atip$atip[mod.atip$atip$type_detected=="LS",3])
predic=pred$pr+wLS
pr<-ts(c(lnserie[length(lnserie)],predic),start=ultim+c(1,0),freq=12)
se<-ts(c(0,pred$se),start=ultim+c(1,0),freq=12)

#Intervals
tl2<-ts(exp(pr-1.96*se),start=ultim+c(1,0),freq=12)
tu2<-ts(exp(pr+1.96*se),start=ultim+c(1,0),freq=12)
pr2<-ts(exp(pr),start=ultim+c(1,0),freq=12)

ts.plot(serie,tl2,tu2,pr2,lty=c(1,2,2,1),col=c(1,4,4,2),xlim=ultim[1]+c(-1,+3),type="o",main="Model ARIMA(0,1,1)(2,1,0)12")
abline(v=(ultim[1]-2):(ultim[1]+3),lty=3,col=4)
```

```{r}
(previs2=window(cbind(tl2,pr2,tu2),start=ultim+c(1,0)))

cbind(previs1,previs2)
```

```{r}
ts.plot(serie,tl1,tu1,pr1,tl2,tu2,pr2,lty=c(1,2,2,1,2,2,1),col=c(1,4,4,2,3,3,6),xlim=ultim[1]+c(1,3),type="o",main="AIRBCN")
legend("topleft",c("ARIMA(0,1,1)(2,1,0)12","ARIMA(0,1,1)(2,1,0)12 with outlier treatment"),col=c(4,3),lty=1,lwd=2)
abline(v=ultim[1]+1:3,lty=3,col=4)
```

```{r}
resul=data.frame(
  par=c(length(coef(mod)),length(coef(mod.lin))+nrow(mod.atip$atip)),
  Sigma2Z=c(mod$sigma2,mod.lin$sigma2),
  AIC=c(AIC(mod),AIC(mod.lin)+2*nrow(mod.atip$atip)),
  BIC=c(BIC(mod),BIC(mod.lin)+log(length(serie)-13)*nrow(mod.atip$atip)),
  RMSPE=c(mod.EQM1,mod.EQM2),
  MAPE=c(mod.EAM1,mod.EAM2),
  meanLength=c(sum(previs1[,3]-previs1[,1]),sum(previs2[,3]-previs2[,1]))/12)
row.names(resul)=c("ARIMA(0,1,1)(1,1,0)12","ARIMA(0,1,1)(1,1,0)12+Atip")

resul
```